import cloudinary from "#/cloud";
import { RequestWithFiles } from "#/middleware/fileParser ";
import { RequestHandler } from "express";
import formidable from "formidable";
import Audio from "#/models/audio";
import { PopulatedFavList } from "#/@types/audio";
import AutoGeneratedPlaylist from "#/models/autoGeneratedPlaylist";

interface CreateAudioRequest extends RequestWithFiles {
  body: { title: string; about: string; category: string };
}

export const createAudio: RequestHandler = async (
  req: CreateAudioRequest,
  res
) => {
  const { title, about, category } = req.body;

  const poster = req.files?.poster as formidable.File;
  const audioFile = req.files?.file as formidable.File;

  const ownerId = req.user.id;

  if (!audioFile) {
    return res.status(422).json({ error: "Audio file is missing !" });
  }

  const audioRes = await cloudinary.uploader.upload(audioFile.filepath, {
    resource_type: "video",
  });

  const newAudio = new Audio({
    title,
    about,
    category,
    owner: ownerId,
    file: {
      url: audioRes.secure_url,
      publicId: audioRes.public_id,
    },
  });

  if (poster) {
    const posterRes = await cloudinary.uploader.upload(poster.filepath, {
      width: 300,
      height: 300,
      crop: "thumb",
      gravity: "face",
    });
    newAudio.poster = {
      url: posterRes.secure_url,
      publicId: posterRes.public_id,
    };
  }

  await newAudio.save();

  res.status(201).json({
    audio: {
      title,
      about,
      file: newAudio.file.url,
      poster: newAudio.poster?.url,
    },
  });
};

export const updateAudio: RequestHandler = async (
  req: CreateAudioRequest,
  res
) => {
  try {
  } catch (error) {}
  const { title, about, category } = req.body;

  const poster = req.files?.poster as formidable.File;

  const ownerId = req.user.id;

  const { audioId } = req.params;

  //new: true returns updated record
  const audio = await Audio.findOneAndUpdate(
    { owner: ownerId, _id: audioId },
    {
      title,
      about,
      category,
    },
    { new: true }
  );

  if (!audio) return res.status(404).json({ error: "Record not found!" });

  if (poster) {
    if (audio.poster?.publicId) {
      await cloudinary.uploader.destroy(audio.poster?.publicId);
    }

    const posterRes = await cloudinary.uploader.upload(poster.filepath, {
      width: 300,
      height: 300,
      crop: "thumb",
      gravity: "face",
    });
    audio.poster = {
      url: posterRes.secure_url,
      publicId: posterRes.public_id,
    };
    await audio.save();
  }

  res.status(201).json({
    audio: {
      title,
      about,
      file: audio.file.url,
      poster: audio.poster?.url,
    },
  });
};

export const getLatestUploads: RequestHandler = async (req, res) => {
  const list = await Audio.find()
    .sort("-createdAt")
    .limit(10)
    .populate<PopulatedFavList>("owner");

  const audios = list.map((item) => {
    return {
      id: item._id,
      title: item.title,
      about: item.about,
      categorty: item.category,
      file: item.file.url,
      poster: item.poster?.url,
      owner: {
        id: item.owner._id,
        name: item.owner.name,
      },
    };
  });

  res.json(audios);
};

export const testFun: RequestHandler = async (req, res) => {
  const result = await Audio.aggregate([
    { $sort: { likes: -1 } },
    {
      $group: {
        _id: "$category",
        audios: {
          $push: "$$ROOT._id",
        },
      },
    },
    {
      $limit: 20,
    },
  ]);
  result.map(async (item) => {
    await AutoGeneratedPlaylist.updateOne(
      {
        //title will be most liked audio by category
        title: item._id,
      },
      {
        $set: {
          items: item.audios,
        },
      },
      //upsert: true will create new one with same title in AutoGeneratedPlaylist if title is not found
      {
        upsert: true,
      }
    );
  });
  res.json(result);
};
